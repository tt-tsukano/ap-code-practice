# 【不具合報告】開発環境における広範囲な無限リロード及びハイドレーションエラー

- **報告日:** 2025年7月12日
- **報告者:** 
- **ステータス:** 要対応

---

## 1. 現象

開発サーバー(`npm run dev`)にて、アプリケーションの複数ページで無限リロードやUIの表示不整合が断続的に発生し、開発が困難な状況です。

-   **代表例: `/demo/problems` ページ**
    -   ページにアクセスすると、ブラウザが無限にリロードを繰り返します。
    -   ターミナルには、Next.jsのFast Refreshの失敗と`webpack.hot-update.json` の404エラーが繰り返し出力されます。
-   **その他のページ**
    -   `/demo/python`、`/demo/sql` といった、Pyodideやsql.jsなどクライアントサイドで重い処理を行うコンポーネントを読み込むページでも、同様の無限リロードやハイドレーションエラー(`Error: Text content does not match server-rendered HTML.`)が確認されています。

これらの状況から、特定ページの問題ではなく、**アプリケーション全体でクライアントサイドの非同期処理に関する共通の課題**を抱えているものと考えられます。

### 添付資料

-   **ハイドレーションエラーのスクリーンショット:**
    ![ハイドレーションエラー](image_e16801.png)
-   **ターミナルログ抜粋:**
    ```
    ⚠ Fast Refresh had to perform a full reload. Read more: [https://nextjs.org/docs/messages/fast-refresh-reload](https://nextjs.org/docs/messages/fast-refresh-reload)
     GET /demo/problems 200 in 6ms
     GET /_next/static/webpack/30e8b2a744f257cb.webpack.hot-update.json 404 in 6ms
    ⚠ Fast Refresh had to perform a full reload. Read more: [https://nextjs.org/docs/messages/fast-refresh-reload](https://nextjs.org/docs/messages/fast-refresh-reload)
    ```

---

## 2. 原因分析

根本的な原因は、複数のページにわたり **サーバーサイドレンダリング(SSR)とクライアントサイドレンダリングの結果が一致しないこと（ハイドレーションエラー）** に起因すると考えられます。

1.  **非同期コンポーネントの読み込み**:
    -   `PyodideRunner` や `SqlRunner` など、多くの主要コンポーネントが `dynamic` を使ってクライアントサイドでのみ読み込まれるように設定されています (`ssr: false`)。
    -   この際、サーバーは `loading` 用のコンポーネントを描画しますが、クライアントサイドでJavaScriptが実行され、実際のコンポーネントに置き換わるまでの間にHTML構造の不一致が発生し、ハイドレーションエラーの引き金となっている可能性が高いです。

2.  **Fast Refresh の不安定化**:
    -   ハイドレーションエラーが発生すると、Next.jsのFast Refresh機能は状態を正しく保てなくなり、安全策としてフルリロードを実行します。
    -   このフルリロードが各ページで繰り返しトリガーされ、無限リロードに陥っていると推測されます。

3.  **過去の類似事例**:
    -   プロジェクトのドキュメント(`テスト結果.md`)にも、過去に同様のハイドレーションエラー（`ThemeToggle`コンポーネントや`index.tsx`での`Math.random()`の使用）を修正した記録があり、この種の問題が再発しやすい構造になっていることが示唆されます。

---

## 3. 提案する解決策

問題が広範囲に及ぶため、場当たり的な修正ではなく、アプリケーション全体で一貫した方針を適用する必要があります。

### ステップ1: (緊急対応) キャッシュのクリア

まず、開発を再開するために各開発者が手元でキャッシュをクリアすることを推奨します。

```bash
# プロジェクトルートで実行
rm -rf .next
rm -rf node_modules
npm install
```

### ステップ2: (恒久対策) クライアント専用コンポーネントのレンダリング戦略見直し

ハイドレーションエラーを根本的に解決するため、クライアントサイドでのみ動作するコンポーネントの扱い方を統一します。

#### a. マウント状態の管理

`useEffect` を使用してコンポーネントがクライアントサイドでマウントされたことを確認できるまで、レンダリングを保留する（または一貫したプレースホルダーを表示する）手法を導入します。これは `ThemeToggle` コンポーネントで既に採用されている実績のある方法です。

**修正例 (`pages/demo/python.tsx`など):**
```tsx
import { useState, useEffect } from 'react';
// ...他のimport

export default function PythonDemo() {
  const [isMounted, setIsMounted] = useState(false);

  useEffect(() => {
    setIsMounted(true);
  }, []);

  // ...

  return (
    <div className="container ...">
      {/* ... */}
      <div className="space-y-6">
        {/* isMountedがtrueになるまで読み込み中などを表示 */}
        {isMounted ? (
          <PyodideRunner onExecutionComplete={handleExecutionComplete} />
        ) : (
          <div>コンポーネントを準備中...</div>
        )}
        {/* ... */}
      </div>
    </div>
  );
}
```

#### b. データ取得方法の統一 (`/demo/problems`向け)

`/demo/problems` のように、ページ表示に必要なデータを事前に取得できる場合は、`getStaticProps` を使用してビルド時にデータを組み込みます。これにより、該当ページのハイドレーションエラーは完全に解消されます。

**修正方針:**
1. `pages/demo/problems.tsx`に`getStaticProps`を実装し、サーバーサイドで`ProblemLoader.loadAllProblems()`を実行します。
2. 取得したデータをコンポーネントのpropsとして渡し、`useEffect`でのデータ取得ロジックを削除します。

これらの対策を講じることで、アプリケーション全体の安定性が向上し、開発効率の改善が見込まれます。

---
